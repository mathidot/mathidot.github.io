# 第一个进程的产生

CPUs provide a special instruction that switches the CPU from user mode to supervisor mode and enters the kernel at an entry point specified by the kernel.(RISC-V provides the `ecall` instruction for this purpose.) Once the CPU has switched to supervisor mode, the kernel can then validate the arguments of the system call(e.g.,check if the address passed to the system call is part of the application's memory),decide whether the application is allowed to perform the requested operation(e.g., check if the applications is allowed to write the specified file), and then deny it or execute it. It is important that the kernel control the kernel entry point, a malicious application could, for example, enter the kernel at a point where the validation of arguments is skipped.

**The mechanisms used by the kernel to implement processes include the user/supervisor mode flag, address spaces, and time-slicing of threads.**

## 进程的虚拟内存分布

![Chapter 1 The first process — xv6 0 documentation](https://pekopeko11.sakura.ne.jp/unix_v6/xv6-book/en/_images/F1-1.png)

An address space includes the process's *user memory* starting at virtual address zero. Instructions come first, followed by global variables, then stack, and finally a "heap" area(for malloc) that the process can expand as needed.

There are a number of factors that limit the maximum size of a process's address space: pointers on the RISC-V are 64 bits wide; the hardware only uses the low 39 bits. Thus, the maximum address is $2^{38} - 1 = 0×3FFFFFFFFF$,which is `MAXVA`. At the top of the address space xv6 reserves a page for *trampoline* and a page mapping the process's *`trapframe`*. Xv6 uses these two pages to transition in and out of the kernel and mapping the*`trapframe `* is necessary to save/restore the state of the user process.

* xv6进程的状态信息存储在`struct proc` 
* A process can make a system call by executing the RISC-V `ecall`instruction. This instruction raises the hardware privilege level and changes the program counter to a kernel-defined entry point. The code at the entry point switches to a kernel stack and executes the kernel instructions that implement the system call. 
* When the system call completes, the kernel switches back to the user stack and returns to user space by calling `sret`instruction, which lowers the hardware privilege level and resumes executing user instructions just after the system call instruction. 
* A process's thread can "block" in the kernel to wait for I/O, and resume where it left off when the I/O has finished
* `p->state` indicates whether the process is allocated, ready to run, running, waiting for I/O, or exiting.
* `p->pagetable` holds the process's page table, in the format that the RISC-V hardware expects. Xv6 causes the paging hardware to use a process's `p->pagetable` when executing that process in user space. A process's page table also serves as the record of the address of the physical pages allocated to store the process's memory.















































