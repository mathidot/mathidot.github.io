---
layout : post
titile : 人脸美颜
tags : Python Opencv Dlib   
---



# 实时人脸美颜实现

## 项目所需库

1. dlib
   Dlib是一个包含机器学习算法的C++开源工具包。Dlib可以帮助您创建很多复杂的机器学习方面的软件来帮助解决实际问题。目前Dlib已经被广泛的用在行业和学术领域，包括机器人，嵌入式设备，移动电话和大型高性能计算环境。

2. Opencv

   OpenCV（Open Source Computer Vision Library）开放源代码计算机视觉库，主要算法涉及图像处理、计算机视觉和机器学习相关方法。OpenCV 其实就是一堆 C 和 C++语言的源代码文件，这些源代码文件中实现了许多常用的计算机视觉算法。OpenCV 可用于开发实时的图像处理、计算机视觉以及模式识别程序。
   OpenCV由一系列C函数和C++类构成，它有C，C++，Python和java接口，当前SDK（Software Development Kit软件开发工具包） 已经支持C++、Java、Python等语言应用开发， 当前OpenCV本身新开发的算法和模块接口都是基于C++产生。
   其覆盖了工业产品检测、医学成像、无人机飞行、无人驾驶、安防、 卫星地图与电子地图拼接、信息安全、用户界面、摄像机标定、立体视觉和机器人等计算机视觉应用领域.

## 实现思路

项目目的是对视频流中出现的每一张人脸进行美颜，每一张图片分为人脸区域和非人脸区域，我们只希望处理人脸区域。所以我们首先利用Dlib库提取出每张图片中人脸特征点的信息，将只包含人脸部分的图像提取出来，我们知道每张人脸由五官，脸颊，下巴和额头组成，我们希望能对每个区域进行不同的美颜处理，这就需要我们将各个部位的特征点信息单独提取提取出来，然后对各个部分的特征点信息进行相应不同的操作。实现代码如下：

```python
PREDICTOR_PATH = './data'
detector = dlib.get_frontal_face_detector()
predictor = dlib.shape_predictor(PREDICTOR_PATH)

def get_landmarks(im):
    rects = detector(im, 1)
    return [numpy.matrix([[p.x, p.y] for p in predictor(im, rect).parts()]) for rect in rects]

organs_name=['jaw','mouth','nose','left eye','right eye','left brow','right brow']
organs_points=[list(range(0, 17)),list(range(48, 61)),list(range(27, 35)),list(range(42, 48)),list(range(36, 42)),list(range(22, 27)),list(range(17, 22))]


```

我们怎么利用这些坐标来针对每个部件的有效区域进行美化处理呢？

首先，获得特征点坐标的边界，再根据区域大小，适当扩大一部分，取对应的储存图片数据的Numpy数组的切片。这样我们就得到了全局图片的一个局部切片

```python
def get_rect(self):
    '''
    获得定位方框
    '''
    ys,xs=self.landmark[:,1],self.landmark[:,0]
    self.top,self.bottom,self.left,self.right=np.min(ys),np.max(ys),np.min(xs),np.max(xs)
self.shape=(int(self.bottom-self.top),int(self.right-self.left))
self.size=self.shape[0]*self.shape[1]*3
self.move=int(np.sqrt(self.size/3)/20)
patch=im[np.max([self.top-self.move,0]):np.min([self.bottom+self.move,shape[0]]),np.max([self.left-self.move,0]):np.min([self.right+self.move,shape[1]])]
```

接下来我们要根据特征点在一个和局部切片形状相同的mask图册被封杀部分勾画部件轮廓。这个mask层只在有效区域值为0-1，其余部分为0.我们使用opencv的convexHull和fillConvexPoly函数。同时 ，我们不希望遮罩很僵硬，使用要用高斯模糊处理。

```python
def _draw_convex_hull(self,im, points, color):
    '''
    勾画多凸边形
    '''
    points = cv2.convexHull(points)
    cv2.fillConvexPoly(im, points, color=color)
    
def get_mask_re(self,ksize=None):
    '''
    获得局部相对坐标遮罩
    '''
    if ksize==None:
        ksize=self.ksize
    landmark_re=self.landmark.copy()
    landmark_re[:,1]-=np.max([self.top-self.move,0])
    landmark_re[:,0]-=np.max([self.left-self.move,0])
    mask = np.zeros(self.patch_bgr.shape[:2], dtype=np.float64)

    self._draw_convex_hull(mask,
                     landmark_re,
                     color=1)

    mask = np.array([mask, mask, mask]).transpose((1, 2, 0))

    mask = (cv2.GaussianBlur(mask, ksize, 0) > 0) * 1.0
    return cv2.GaussianBlur(mask, ksize, 0)[:]

```

