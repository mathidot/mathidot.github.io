

---

layout : post
titile :数据整理
tags : 缺失的计算机课程

---

`journalctl | grep -i intel`，它会找到所有包含intel（不区分大小写）的系统日志。

数据处理不可缺少的两样东西：

* 用来整理的数据
* 相关的应用场景

日志处理通常是一个比较典型的使用场景，因为我们经常需要哎日志中查找某些信息，这种情况下通读日志是不现实的。现在，让我们研究一下系统日志，看看哪些用户尝试登陆过我们的服务器:

```shell
ssh myserver journalctl
```

内容太多了，现在把涉及`sshd`的信息过滤出来：

```shell
ssh myserver journalctl | grep sshd
```

这里我们使用管道将一个远程服务器上的文件传递给本机的`grep`程序！此时我们打印出来的内容，仍然比我们需要的要多得多，读起来非常费劲，我们改进一下：

```shell
ssh myserver 'journalctl | grep sshd | grep "Disconnected from"' | less
```

多出来的引号是什么作用呢？这么说吧，我们的日志是一个非常大的文件，把这么大的文件流直接传输到我们本地的电脑上在进行过滤是对流量的一种浪费。因此我们采取另外一种方式，我们先在远端机器上过滤文本内容，然后再将结果传输到本机。`less`为我们创建了一个文件分页器，使我们可以通过翻页的方式浏览较长的文本。为了进一步节省流量，我们甚至可以将当前过滤处的日志保存到文件中，这样后续就不需要再次通过网络访问该文件了：

```shell
ssh myserver 'journalctl | grep sshd | grep "Disconnected from"' > ssh.log
less ssh.log
```

过滤结果中仍然包含不少没用的数据，我们有很多办法可以删除这些无用的数据，但是让我们先研究一下`sed`这个非常强大的工具。

`sed`是一个基于文本编辑器`ed`构建的“流编辑器”。在`sed`中，你基本上是利用一些简短的命令来修改文件，而不是直接操作文件的内容。相关的命名非常多，但是最常用的是`s`，即替换命令。例如我们可以这样写：

```shell
ssh myserver journalctl
	| grep sshd
	| grep "Disconnected from"
	| sed 's/.*Disconnected from //'
```

上面这段命令中，我们使用了一段简单的正则表达式。正则表达式是一种非常强大的工具，可以让我们基于某种模式来对字符串进行匹配。`s`命令的语法如下：`s/REGEX/SUBSTITUTION`,其中`REGEX`部分是我们需要使用的正则表达式，而`SUBSTITUTION`是用于替换匹配结果的文本

## 正则表达式

- `.` 除换行符之外的”任意单个字符”
- `*` 匹配前面字符零次或多次
- `+` 匹配前面字符一次或多次
- `[abc]` 匹配 `a`, `b` 和 `c` 中的任意一个
- `(RX1|RX2)` 任何能够匹配`RX1` 或 `RX2`的结果
- `^` 行首
- `$` 行尾

`sed`的正则表达式有些时候是比较奇怪的，它需要你在这些模式前添加`\`才能使其具有特殊含义。或者，你页可以添加`-E`选项来支持这些匹配。

回过头来看`/.*Disconnected from /`，我们会发现这个正则表达式可以匹配任意以若干字符开头，并接着包含`Disconnected from`的字符串，这正是我们希望的。但是如果有人将“Disconnected from”作为自己的用户名呢？

```shell
Jan 17 03:13:00 thesquareplanet.com sshd[2631]: Disconnected from invalid user Disconnected from 46.97.239.16 port 55920 [preauth]
```

正则式会如何匹配？`*`和`+`在默认情况下是贪婪模式，也就是说，它们会尽可能多的匹配文本。因此对上述字符串的匹配结果如下：

```shell
46.97.239.16 port 55920 [preauth]
```

这可不是我们想要的结果。对于某些正则表达式的实现来说，你可以给`*`或`+` 增加一个`?` 后缀使其变成非贪婪模式，但是很可惜 `sed` 并不支持该后缀。不过，我们可以切换到 perl 的命令行模式，该模式支持编写这样的正则表达式：

```shell
perl -pe 's/.*?Disconnected from //'
```

让我们回到 `sed` 命令并使用它完成后续的任务，毕竟对于这一类任务，`sed`是最常见的工具。`sed` 还可以非常方便的做一些事情，例如打印匹配后的内容，一次调用中进行多次替换搜索等。但是这些内容我们并不会在此进行介绍。`sed` 本身是一个非常全能的工具，但是在具体功能上往往能找到更好的工具作为替代品。

好的，我们还需要去掉用户名的