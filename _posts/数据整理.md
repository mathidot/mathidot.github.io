

---

layout : post
titile :数据整理
tags : 缺失的计算机课程

---

`journalctl | grep -i intel`，它会找到所有包含intel（不区分大小写）的系统日志。

数据处理不可缺少的两样东西：

* 用来整理的数据
* 相关的应用场景

日志处理通常是一个比较典型的使用场景，因为我们经常需要哎日志中查找某些信息，这种情况下通读日志是不现实的。现在，让我们研究一下系统日志，看看哪些用户尝试登陆过我们的服务器:

```shell
ssh myserver journalctl
```

内容太多了，现在把涉及`sshd`的信息过滤出来：

```shell
ssh myserver journalctl | grep sshd
```

这里我们使用管道将一个远程服务器上的文件传递给本机的`grep`程序！此时我们打印出来的内容，仍然比我们需要的要多得多，读起来非常费劲，我们改进一下：

```shell
ssh myserver 'journalctl | grep sshd | grep "Disconnected from"' | less
```

多出来的引号是什么作用呢？这么说吧，我们的日志是一个非常大的文件，把这么大的文件流直接传输到我们本地的电脑上在进行过滤是对流量的一种浪费。因此我们采取另外一种方式，我们先在远端机器上过滤文本内容，然后再将结果传输到本机。`less`为我们创建了一个文件分页器，使我们可以通过翻页的方式浏览较长的文本。为了进一步节省流量，我们甚至可以将当前过滤处的日志保存到文件中，这样后续就不需要再次通过网络访问该文件了：

```shell
ssh myserver 'journalctl | grep sshd | grep "Disconnected from"' > ssh.log
less ssh.log
```

过滤结果中仍然包含不少没用的数据，我们有很多办法可以删除这些无用的数据，但是让我们先研究一下`sed`这个非常强大的工具。

`sed`是一个基于文本编辑器`ed`构建的“流编辑器”。在`sed`中，你基本上是利用一些简短的命令来修改文件，而不是直接操作文件的内容。相关的命名非常多，但是最常用的是`s`，即替换命令。例如我们可以这样写：

```shell
ssh myserver journalctl
	| grep sshd
	| grep "Disconnected from"
	| sed 's/.*Disconnected from //'
```

上面这段命令中，我们使用了一段简单的正则表达式。正则表达式是一种非常强大的工具，可以让我们基于某种模式来对字符串进行匹配。`s`命令的语法如下：`s/REGEX/SUBSTITUTION`,其中`REGEX`部分是我们需要使用的正则表达式，而`SUBSTITUTION`是用于替换匹配结果的文本

## 正则表达式

- `.` 除换行符之外的”任意单个字符”
- `*` 匹配前面字符零次或多次
- `+` 匹配前面字符一次或多次
- `[abc]` 匹配 `a`, `b` 和 `c` 中的任意一个
- `(RX1|RX2)` 任何能够匹配`RX1` 或 `RX2`的结果
- `^` 行首
- `$` 行尾